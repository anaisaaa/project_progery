////////////////////////////////////////////////////////////
//
// SFML - Simple and Fast Multimedia Library
// Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
//
// Данное программное обеспечение предоставляется "как есть", без каких-либо гарантий.
// Авторы не несут ответственности за любые убытки, вызванные использованием этого ПО.
//
// Разрешается использовать это ПО для любых целей, включая коммерческие приложения,
// а также модифицировать и свободно распространять при соблюдении следующих условий:
//
// 1. Нельзя выдавать себя за автора оригинального ПО;
//    запрещено утверждать, что вы написали оригинальное ПО.
//    При использовании в продукте, указание авторства приветствуется, но не обязательно.
//
// 2. Измененные версии должны быть явно обозначены как таковые
//    и не должны выдаваться за оригинальное ПО.
//
// 3. Данное уведомление не может быть удалено или изменено.
//
////////////////////////////////////////////////////////////

#ifndef SFML_DRAWABLE_HPP
#define SFML_DRAWABLE_HPP

////////////////////////////////////////////////////////////
// Заголовочные файлы
////////////////////////////////////////////////////////////
#include <SFML/Graphics/Export.hpp>
#include <SFML/Graphics/RenderStates.hpp>

namespace sf
{
class RenderTarget;

////////////////////////////////////////////////////////////
/// \brief Абстрактный базовый класс для объектов, которые можно
///        отрисовывать на цели рендеринга
///
////////////////////////////////////////////////////////////
class SFML_GRAPHICS_API Drawable
{
public:

    ////////////////////////////////////////////////////////////
    /// \brief Виртуальный деструктор
    ///
    ////////////////////////////////////////////////////////////
    virtual ~Drawable() {}

protected:

    friend class RenderTarget;

    ////////////////////////////////////////////////////////////
    /// \brief Отрисовка объекта на цели рендеринга
    ///
    /// Это чисто виртуальная функция, которая должна быть реализована
    /// в производном классе для определения способа отрисовки объекта.
    ///
    /// \param target Цель рендеринга для отрисовки
    /// \param states Текущие состояния рендеринга
    ///
    ////////////////////////////////////////////////////////////
    virtual void draw(RenderTarget& target, RenderStates states) const = 0;
};

} // namespace sf

#endif // SFML_DRAWABLE_HPP

////////////////////////////////////////////////////////////
/// \class sf::Drawable
/// \ingroup graphics
///
/// sf::Drawable - это очень простой базовый класс, который позволяет
/// объектам производных классов отрисовываться на sf::RenderTarget.
///
/// Все, что нужно сделать в производном классе - переопределить
/// виртуальную функцию draw.
///
/// Обратите внимание, что наследование от sf::Drawable не является
/// обязательным, но оно позволяет использовать удобный синтаксис
/// "window.draw(object)" вместо "object.draw(window)", что более
/// согласовано с другими классами SFML.
///
/// Пример:
/// \code
/// class MyDrawable : public sf::Drawable
/// {
/// public:
///
///    ...
///
/// private:
///
///     virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const
///     {
///         // Можно отрисовывать другие высокоуровневые объекты
///         target.draw(m_sprite, states);
///
///         // ... или использовать низкоуровневый API
///         states.texture = &m_texture;
///         target.draw(m_vertices, states);
///
///         // ... или рисовать напрямую через OpenGL
///         glBegin(GL_QUADS);
///         ...
///         glEnd();
///     }
///
///     sf::Sprite m_sprite;
///     sf::Texture m_texture;
///     sf::VertexArray m_vertices;
/// };
/// \endcode
///
/// \see sf::RenderTarget
///
////////////////////////////////////////////////////////////
