////////////////////////////////////////////////////////////
//
// SFML - Simple and Fast Multimedia Library
// Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
//
// Данное программное обеспечение предоставляется "как есть", без каких-либо гарантий.
// Авторы не несут ответственности за любые убытки, вызванные использованием этого ПО.
//
// Разрешается использовать это ПО для любых целей, включая коммерческие приложения,
// а также модифицировать и свободно распространять при соблюдении следующих условий:
//
// 1. Нельзя выдавать себя за автора оригинального ПО;
//    запрещено утверждать, что вы написали оригинальное ПО.
//    При использовании в продукте, указание авторства приветствуется, но не обязательно.
//
// 2. Измененные версии должны быть явно обозначены как таковые
//    и не должны выдаваться за оригинальное ПО.
//
// 3. Данное уведомление не может быть удалено или изменено.
//
////////////////////////////////////////////////////////////

#ifndef SFML_FONT_HPP
#define SFML_FONT_HPP

////////////////////////////////////////////////////////////
// Заголовочные файлы
////////////////////////////////////////////////////////////
#include <SFML/Graphics/Export.hpp>
#include <SFML/Graphics/Glyph.hpp>
#include <SFML/Graphics/Texture.hpp>
#include <SFML/Graphics/Rect.hpp>
#include <SFML/System/Vector2.hpp>
#include <SFML/System/String.hpp>
#include <map>
#include <string>
#include <vector>

namespace sf
{
class InputStream;

////////////////////////////////////////////////////////////
/// \brief Класс для загрузки и работы со шрифтами
///
////////////////////////////////////////////////////////////
class SFML_GRAPHICS_API Font
{
public:

    ////////////////////////////////////////////////////////////
    /// \brief Содержит различную информацию о шрифте
    ///
    ////////////////////////////////////////////////////////////
    struct Info
    {
        std::string family; ///< Название семейства шрифтов
    };

public:

    ////////////////////////////////////////////////////////////
    /// \brief Конструктор по умолчанию
    ///
    /// Создает пустой шрифт
    ///
    ////////////////////////////////////////////////////////////
    Font();

    ////////////////////////////////////////////////////////////
    /// \brief Конструктор копирования
    ///
    /// \param copy Копируемый экземпляр
    ///
    ////////////////////////////////////////////////////////////
    Font(const Font& copy);

    ////////////////////////////////////////////////////////////
    /// \brief Деструктор
    ///
    /// Освобождает все внутренние ресурсы, используемые шрифтом
    ///
    ////////////////////////////////////////////////////////////
    ~Font();

    ////////////////////////////////////////////////////////////
    /// \brief Загрузка шрифта из файла
    ///
    /// Поддерживаемые форматы шрифтов: TrueType, Type 1, CFF,
    /// OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR и Type 42.
    /// Обратите внимание, что эта функция не знает о стандартных
    /// шрифтах, установленных в системе, и не может загружать их напрямую.
    ///
    /// \warning SFML не может предзагрузить все данные шрифта в этой
    /// функции, поэтому файл должен оставаться доступным до тех пор,
    /// пока объект sf::Font не загрузит новый шрифт или не будет уничтожен.
    ///
    /// \param filename Путь к файлу шрифта
    ///
    /// \return True, если загрузка прошла успешно, false в случае ошибки
    ///
    /// \see loadFromMemory, loadFromStream
    ///
    ////////////////////////////////////////////////////////////
    bool loadFromFile(const std::string& filename);

    ////////////////////////////////////////////////////////////
    /// \brief Загрузка шрифта из памяти
    ///
    /// Поддерживаемые форматы шрифтов: TrueType, Type 1, CFF,
    /// OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR и Type 42.
    ///
    /// \warning SFML не может предзагрузить все данные шрифта в этой
    /// функции, поэтому буфер, на который указывает \a data, должен
    /// оставаться валидным до тех пор, пока объект sf::Font не загрузит
    /// новый шрифт или не будет уничтожен.
    ///
    /// \param data        Указатель на данные шрифта в памяти
    /// \param sizeInBytes Размер данных для загрузки в байтах
    ///
    /// \return True, если загрузка прошла успешно, false в случае ошибки
    ///
    /// \see loadFromFile, loadFromStream
    ///
    ////////////////////////////////////////////////////////////
    bool loadFromMemory(const void* data, std::size_t sizeInBytes);

    ////////////////////////////////////////////////////////////
    /// \brief Загрузка шрифта из пользовательского потока
    ///
    /// Поддерживаемые форматы шрифтов: TrueType, Type 1, CFF,
    /// OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR и Type 42.
    ///
    /// \warning SFML не может предзагрузить все данные шрифта в этой
    /// функции, поэтому поток должен оставаться доступным до тех пор,
    /// пока объект sf::Font не загрузит новый шрифт или не будет уничтожен.
    ///
    /// \param stream Исходный поток для чтения
    ///
    /// \return True, если загрузка прошла успешно, false в случае ошибки
    ///
    /// \see loadFromFile, loadFromMemory
    ///
    ////////////////////////////////////////////////////////////
    bool loadFromStream(InputStream& stream);

    ////////////////////////////////////////////////////////////
    /// \brief Получение информации о шрифте
    ///
    /// \return Структура с информацией о шрифте
    ///
    ////////////////////////////////////////////////////////////
    const Info& getInfo() const;

    ////////////////////////////////////////////////////////////
    /// \brief Получение глифа шрифта
    ///
    /// Если шрифт является растровым, не все размеры символов
    /// могут быть доступны. Если глиф недоступен для запрошенного
    /// размера, возвращается пустой глиф.
    ///
    /// Использование отрицательного значения толщины контура
    /// может привести к искаженному отображению.
    ///
    /// \param codePoint        Кодовая точка Unicode символа
    /// \param characterSize    Размер символа
    /// \param bold             Получить жирную версию или обычную?
    /// \param outlineThickness Толщина контура (если не 0, глиф не будет заполнен)
    ///
    /// \return Глиф, соответствующий \a codePoint и \a characterSize
    ///
    ////////////////////////////////////////////////////////////
    const Glyph& getGlyph(Uint32 codePoint, unsigned int characterSize, bool bold, float outlineThickness = 0) const;

    ////////////////////////////////////////////////////////////
    /// \brief Получение кернинга для пары глифов
    ///
    /// Кернинг - это дополнительное смещение (отрицательное),
    /// применяемое между двумя глифами при отрисовке, чтобы
    /// сделать пару более "естественной". Например, пара "AV"
    /// имеет специальный кернинг, чтобы расположить символы ближе.
    /// Большинство пар глифов имеют кернинг, равный нулю.
    ///
    /// \param first         Кодовая точка Unicode первого символа
    /// \param second        Кодовая точка Unicode второго символа
    /// \param characterSize Размер символа
    ///
    /// \return Значение кернинга для \a first и \a second в пикселях
    ///
    ////////////////////////////////////////////////////////////
    float getKerning(Uint32 first, Uint32 second, unsigned int characterSize) const;

    ////////////////////////////////////////////////////////////
    /// \brief Получение межстрочного интервала
    ///
    /// Межстрочный интервал - это вертикальное смещение между
    /// двумя последовательными строками текста.
    ///
    /// \param characterSize Размер символа
    ///
    /// \return Межстрочный интервал в пикселях
    ///
    ////////////////////////////////////////////////////////////
    float getLineSpacing(unsigned int characterSize) const;

    ////////////////////////////////////////////////////////////
    /// \brief Получение позиции подчеркивания
    ///
    /// Позиция подчеркивания - это вертикальное смещение между
    /// базовой линией и подчеркиванием.
    ///
    /// \param characterSize Размер символа
    ///
    /// \return Позиция подчеркивания в пикселях
    ///
    /// \see getUnderlineThickness
    ///
    ////////////////////////////////////////////////////////////
    float getUnderlinePosition(unsigned int characterSize) const;

    ////////////////////////////////////////////////////////////
    /// \brief Получение толщины подчеркивания
    ///
    /// Толщина подчеркивания - это вертикальный размер подчеркивания.
    ///
    /// \param characterSize Размер символа
    ///
    /// \return Толщина подчеркивания в пикселях
    ///
    /// \see getUnderlinePosition
    ///
    ////////////////////////////////////////////////////////////
    float getUnderlineThickness(unsigned int characterSize) const;

    ////////////////////////////////////////////////////////////
    /// \brief Получение текстуры с загруженными глифами определенного размера
    ///
    /// Содержимое возвращаемой текстуры изменяется по мере запроса
    /// новых глифов, поэтому оно не очень релевантно. В основном
    /// используется внутри sf::Text.
    ///
    /// \param characterSize Размер символа
    ///
    /// \return Текстура, содержащая глифы запрошенного размера
    ///
    ////////////////////////////////////////////////////////////
    const Texture& getTexture(unsigned int characterSize) const;

    ////////////////////////////////////////////////////////////
    /// \brief Перегрузка оператора присваивания
    ///
    /// \param right Присваиваемый экземпляр
    ///
    /// \return Ссылка на себя
    ///
    ////////////////////////////////////////////////////////////
    Font& operator =(const Font& right);

private:

    ////////////////////////////////////////////////////////////
    /// \brief Структура, определяющая строку глифов
    ///
    ////////////////////////////////////////////////////////////
    struct Row
    {
        Row(unsigned int rowTop, unsigned int rowHeight) : width(0), top(rowTop), height(rowHeight) {}

        unsigned int width;  ///< Текущая ширина строки
        unsigned int top;    ///< Y-позиция строки в текстуре
        unsigned int height; ///< Высота строки
    };

    ////////////////////////////////////////////////////////////
    // Типы
    ////////////////////////////////////////////////////////////
    typedef std::map<Uint64, Glyph> GlyphTable; ///< Таблица соответствия кодовых точек глифам

    ////////////////////////////////////////////////////////////
    /// \brief Структура, определяющая страницу глифов
    ///
    ////////////////////////////////////////////////////////////
    struct Page
    {
        Page();

        GlyphTable       glyphs;  ///< Таблица соответствия кодовых точек глифам
        Texture          texture; ///< Текстура, содержащая пиксели глифов
        unsigned int     nextRow; ///< Y-позиция следующей новой строки в текстуре
        std::vector<Row> rows;    ///< Список позиций всех существующих строк
    };

    ////////////////////////////////////////////////////////////
    /// \brief Освобождение всех внутренних ресурсов
    ///
    ////////////////////////////////////////////////////////////
    void cleanup();

    ////////////////////////////////////////////////////////////
    /// \brief Загрузка нового глифа и сохранение его в кэше
    ///
    /// \param codePoint        Кодовая точка Unicode символа
    /// \param characterSize    Размер символа
    /// \param bold             Загрузить жирную версию или обычную?
    /// \param outlineThickness Толщина контура (если не 0, глиф не будет заполнен)
    ///
    /// \return Глиф, соответствующий \a codePoint и \a characterSize
    ///
    ////////////////////////////////////////////////////////////
    Glyph loadGlyph(Uint32 codePoint, unsigned int characterSize, bool bold, float outlineThickness) const;

    ////////////////////////////////////////////////////////////
    /// \brief Поиск подходящего прямоугольника в текстуре для глифа
    ///
    /// \param page   Страница глифов для поиска
    /// \param width  Ширина прямоугольника
    /// \param height Высота прямоугольника
    ///
    /// \return Найденный прямоугольник в текстуре
    ///
    ////////////////////////////////////////////////////////////
    IntRect findGlyphRect(Page& page, unsigned int width, unsigned int height) const;

    ////////////////////////////////////////////////////////////
    /// \brief Убедиться, что заданный размер является текущим
    ///
    /// \param characterSize Размер символа
    ///
    /// \return True в случае успеха, false при ошибке
    ///
    ////////////////////////////////////////////////////////////
    bool setCurrentSize(unsigned int characterSize) const;

    ////////////////////////////////////////////////////////////
    // Типы
    ////////////////////////////////////////////////////////////
    typedef std::map<unsigned int, Page> PageTable; ///< Таблица соответствия размеров символов страницам (текстурам)

    ////////////////////////////////////////////////////////////
    // Данные-члены
    ////////////////////////////////////////////////////////////
    void*                      m_library;     ///< Указатель на внутренний интерфейс библиотеки (без типа для скрытия деталей реализации)
    void*                      m_face;        ///< Указатель на внутренний объект шрифта (без типа для скрытия деталей реализации)
    void*                      m_streamRec;   ///< Указатель на запись потока (без типа для скрытия деталей реализации)
    void*                      m_stroker;     ///< Указатель на обводчик (без типа для скрытия деталей реализации)
    int*                       m_refCount;    ///< Счетчик ссылок, используемый для неявного разделения
    Info                       m_info;        ///< Информация о шрифте
    mutable PageTable          m_pages;       ///< Таблица страниц глифов по размерам символов
    mutable std::vector<Uint8> m_pixelBuffer; ///< Буфер пикселей для временного хранения глифов перед записью в текстуру
    #ifdef SFML_SYSTEM_ANDROID
    void*                      m_stream; ///< Поток файла ресурсов (если загружен из файла)
    #endif
};

} // namespace sf

#endif // SFML_FONT_HPP

////////////////////////////////////////////////////////////
/// \class sf::Font
/// \ingroup graphics
///
/// Шрифты могут быть загружены из файла, из памяти или из
/// пользовательского потока и поддерживают наиболее распространенные
/// форматы шрифтов. Полный список поддерживаемых форматов см.
/// в функции loadFromFile.
///
/// После загрузки экземпляр sf::Font предоставляет три типа
/// информации о шрифте:
/// \li Глобальные метрики, такие как межстрочный интервал
/// \li Метрики отдельных глифов, такие как ограничивающий прямоугольник или кернинг
/// \li Пиксельное представление глифов
///
/// Сами по себе шрифты не очень полезны: они содержат данные
/// шрифта, но не могут ничего с ними сделать. Для этого вам
/// нужно использовать класс sf::Text, который может правильно
/// выводить текст с различными параметрами, такими как размер
/// символов, стиль, цвет, позиция, поворот и т.д.
/// Такое разделение обеспечивает большую гибкость и лучшую
/// производительность: sf::Font является ресурсоемким объектом,
/// и любая операция с ним выполняется медленно (часто слишком
/// медленно для приложений реального времени). С другой стороны,
/// sf::Text - это легковесный объект, который может комбинировать
/// данные глифов и метрики sf::Font для отображения любого текста
/// на цели рендеринга.
/// Обратите внимание, что можно привязать несколько экземпляров
/// sf::Text к одному sf::Font.
///
/// Важно отметить, что экземпляр sf::Text не копирует используемый
/// шрифт, а только сохраняет ссылку на него. Таким образом,
/// sf::Font не должен уничтожаться, пока он используется
/// sf::Text (т.е. никогда не пишите функцию, которая использует
/// локальный экземпляр sf::Font для создания текста).
///
/// Пример использования:
/// \code
/// // Объявление нового шрифта
/// sf::Font font;
///
/// // Загрузка из файла
/// if (!font.loadFromFile("arial.ttf"))
/// {
///     // ошибка...
/// }
///
/// // Создание текста с использованием нашего шрифта
/// sf::Text text1;
/// text1.setFont(font);
/// text1.setCharacterSize(30);
/// text1.setStyle(sf::Text::Regular);
///
/// // Создание другого текста с тем же шрифтом, но другими параметрами
/// sf::Text text2;
/// text2.setFont
